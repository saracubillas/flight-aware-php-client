<?php
/**
 * MiscellaneousApi
 * PHP version 5
 *
 * @category Class
 * @package  FlightAware\PHPClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AeroAPI
 *
 * # Introduction AeroAPI is a simple, query-based API that gives software developers access to a variety of FlightAware's flight data. Users can obtain current or historical data. AeroAPI is a RESTful API delivering accurate and actionable aviation data. With the introduction of Foresight™, customers have access to the data that powers over half of the predictive airline ETAs in the US.  ## Categories AeroAPI is divided into several categories to make things easier to discover. - Flights: Summary information, planned routes, positions and more - Foresight: Flight positions enhanced with FlightAware Foresight™ - Airports: Airport information and FIDS style resources - Operators: Operator information and fleet activity resources - Alerts: Configure flight alerts and delivery destinations - History: Historical flight access for various endpoints - Miscellaneous: Flight disruption, future schedule information, and aircraft owner information  ## Development Tools AeroAPI is defined using the OpenAPI Spec 3.0, which means it can be easily imported into tools like Postman. To get started try importing the API specification using [Postman's instructions](https://learning.postman.com/docs/integrations/available-integrations/working-with-openAPI/). Once imported as a collection only the \"Value\" field under the collection's Authorization tab needs to be populated and saved before making calls.  The AeroAPI OpenAPI specification is located at:\\ https://flightaware.com/commercial/aeroapi/resources/aeroapi-openapi.yml  Our [open source AeroApps project](/aeroapi/portal/resources) provides a small collection of services and sample applications to help you get started.  The Flight Information Display System (FIDS) AeroApp is an example of a multi-tier application using multiple languages and Docker containers. It demonstrates connectivity, data caching, flight presentation, and leveraging flight maps.  The Alerts AeroApp demonstrates the use of AeroAPI to set, edit, and receive alerts in a sample application with a Dockerized Python backend and a React frontend.  Our AeroAPI push notification [testing interface](/commercial/aeroapi/send.rvt) provides a quick and easy way to test the delivery of customized alerts via AeroAPI push.
 *
 * OpenAPI spec version: 4.12
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.42
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace FlightAware\PHPClient\FlightAwarePHPClient;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use FlightAware\PHPClient\ApiException;
use FlightAware\PHPClient\Configuration;
use FlightAware\PHPClient\HeaderSelector;
use FlightAware\PHPClient\ObjectSerializer;

/**
 * MiscellaneousApi Class Doc Comment
 *
 * @category Class
 * @package  FlightAware\PHPClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class MiscellaneousApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    public function getAircraftOwner($ident)
    {
        list($response) = $this->getAircraftOwnerWithHttpInfo($ident);
        return $response;
    }


    public function getAircraftOwnerWithHttpInfo($ident)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20037';
        $request = $this->getAircraftOwnerRequest($ident);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20037',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAircraftOwnerAsync
     *
     * Get the owner of an aircraft
     *
     * @param  string $ident The ident or registration of the aircraft (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAircraftOwnerAsync($ident)
    {
        return $this->getAircraftOwnerAsyncWithHttpInfo($ident)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAircraftOwnerAsyncWithHttpInfo
     *
     * Get the owner of an aircraft
     *
     * @param  string $ident The ident or registration of the aircraft (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAircraftOwnerAsyncWithHttpInfo($ident)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20037';
        $request = $this->getAircraftOwnerRequest($ident);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAircraftOwner'
     *
     * @param  string $ident The ident or registration of the aircraft (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAircraftOwnerRequest($ident)
    {
        // verify the required parameter 'ident' is set
        if ($ident === null || (is_array($ident) && count($ident) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ident when calling getAircraftOwner'
            );
        }

        $resourcePath = '/aircraft/{ident}/owner';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($ident !== null) {
            $resourcePath = str_replace(
                '{' . 'ident' . '}',
                ObjectSerializer::toPathValue($ident),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllDisruptionCounts
     *
     * Get global flight disruption statistics
     *
     * @param  string $entity_type The type of entity to get disruption statistics for. (required)
     * @param  string $time_period time_period (optional, default to today)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20040
     */
    public function getAllDisruptionCounts($entity_type, $time_period = 'today', $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getAllDisruptionCountsWithHttpInfo($entity_type, $time_period, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getAllDisruptionCountsWithHttpInfo
     *
     * Get global flight disruption statistics
     *
     * @param  string $entity_type The type of entity to get disruption statistics for. (required)
     * @param  string $time_period (optional, default to today)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20040, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllDisruptionCountsWithHttpInfo($entity_type, $time_period = 'today', $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20040';
        $request = $this->getAllDisruptionCountsRequest($entity_type, $time_period, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20040',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllDisruptionCountsAsync
     *
     * Get global flight disruption statistics
     *
     * @param  string $entity_type The type of entity to get disruption statistics for. (required)
     * @param  string $time_period (optional, default to today)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllDisruptionCountsAsync($entity_type, $time_period = 'today', $max_pages = '1', $cursor = null)
    {
        return $this->getAllDisruptionCountsAsyncWithHttpInfo($entity_type, $time_period, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllDisruptionCountsAsyncWithHttpInfo
     *
     * Get global flight disruption statistics
     *
     * @param  string $entity_type The type of entity to get disruption statistics for. (required)
     * @param  string $time_period (optional, default to today)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllDisruptionCountsAsyncWithHttpInfo($entity_type, $time_period = 'today', $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20040';
        $request = $this->getAllDisruptionCountsRequest($entity_type, $time_period, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllDisruptionCounts'
     *
     * @param  string $entity_type The type of entity to get disruption statistics for. (required)
     * @param  string $time_period (optional, default to today)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllDisruptionCountsRequest($entity_type, $time_period = 'today', $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'entity_type' is set
        if ($entity_type === null || (is_array($entity_type) && count($entity_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entity_type when calling getAllDisruptionCounts'
            );
        }

        $resourcePath = '/disruption_counts/{entity_type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($time_period !== null) {
            $queryParams['time_period'] = ObjectSerializer::toQueryValue($time_period, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($entity_type !== null) {
            $resourcePath = str_replace(
                '{' . 'entity_type' . '}',
                ObjectSerializer::toPathValue($entity_type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDisruptionCounts
     *
     * Get flight disruption statistics for a particular entity
     *
     * @param  string $id The ICAO code for the airline or ID for the airport (ICAO, IATA, or LID) for which you are fetching disruption statistics.  For airport ID, [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $entity_type The type of entity to get disruption statistics for. (required)
     * @param  string $time_period time_period (optional, default to today)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20041
     */
    public function getDisruptionCounts($id, $entity_type, $time_period = 'today')
    {
        list($response) = $this->getDisruptionCountsWithHttpInfo($id, $entity_type, $time_period);
        return $response;
    }

    /**
     * Operation getDisruptionCountsWithHttpInfo
     *
     * Get flight disruption statistics for a particular entity
     *
     * @param  string $id The ICAO code for the airline or ID for the airport (ICAO, IATA, or LID) for which you are fetching disruption statistics.  For airport ID, [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $entity_type The type of entity to get disruption statistics for. (required)
     * @param  string $time_period (optional, default to today)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20041, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDisruptionCountsWithHttpInfo($id, $entity_type, $time_period = 'today')
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20041';
        $request = $this->getDisruptionCountsRequest($id, $entity_type, $time_period);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20041',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDisruptionCountsAsync
     *
     * Get flight disruption statistics for a particular entity
     *
     * @param  string $id The ICAO code for the airline or ID for the airport (ICAO, IATA, or LID) for which you are fetching disruption statistics.  For airport ID, [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $entity_type The type of entity to get disruption statistics for. (required)
     * @param  string $time_period (optional, default to today)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDisruptionCountsAsync($id, $entity_type, $time_period = 'today')
    {
        return $this->getDisruptionCountsAsyncWithHttpInfo($id, $entity_type, $time_period)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDisruptionCountsAsyncWithHttpInfo
     *
     * Get flight disruption statistics for a particular entity
     *
     * @param  string $id The ICAO code for the airline or ID for the airport (ICAO, IATA, or LID) for which you are fetching disruption statistics.  For airport ID, [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $entity_type The type of entity to get disruption statistics for. (required)
     * @param  string $time_period (optional, default to today)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDisruptionCountsAsyncWithHttpInfo($id, $entity_type, $time_period = 'today')
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20041';
        $request = $this->getDisruptionCountsRequest($id, $entity_type, $time_period);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDisruptionCounts'
     *
     * @param  string $id The ICAO code for the airline or ID for the airport (ICAO, IATA, or LID) for which you are fetching disruption statistics.  For airport ID, [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $entity_type The type of entity to get disruption statistics for. (required)
     * @param  string $time_period (optional, default to today)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDisruptionCountsRequest($id, $entity_type, $time_period = 'today')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDisruptionCounts'
            );
        }
        // verify the required parameter 'entity_type' is set
        if ($entity_type === null || (is_array($entity_type) && count($entity_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entity_type when calling getDisruptionCounts'
            );
        }

        $resourcePath = '/disruption_counts/{entity_type}/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($time_period !== null) {
            $queryParams['time_period'] = ObjectSerializer::toQueryValue($time_period, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($entity_type !== null) {
            $resourcePath = str_replace(
                '{' . 'entity_type' . '}',
                ObjectSerializer::toPathValue($entity_type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFlightType
     *
     * Get information about an aircraft type
     *
     * @param  string $type The ICAO aircraft type designator for the aircraft to fetch information for (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20038
     */
    public function getFlightType($type)
    {
        list($response) = $this->getFlightTypeWithHttpInfo($type);
        return $response;
    }

    /**
     * Operation getFlightTypeWithHttpInfo
     *
     * Get information about an aircraft type
     *
     * @param  string $type The ICAO aircraft type designator for the aircraft to fetch information for (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20038, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFlightTypeWithHttpInfo($type)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20038';
        $request = $this->getFlightTypeRequest($type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20038',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFlightTypeAsync
     *
     * Get information about an aircraft type
     *
     * @param  string $type The ICAO aircraft type designator for the aircraft to fetch information for (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlightTypeAsync($type)
    {
        return $this->getFlightTypeAsyncWithHttpInfo($type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFlightTypeAsyncWithHttpInfo
     *
     * Get information about an aircraft type
     *
     * @param  string $type The ICAO aircraft type designator for the aircraft to fetch information for (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlightTypeAsyncWithHttpInfo($type)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20038';
        $request = $this->getFlightTypeRequest($type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFlightType'
     *
     * @param  string $type The ICAO aircraft type designator for the aircraft to fetch information for (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFlightTypeRequest($type)
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling getFlightType'
            );
        }

        $resourcePath = '/aircraft/types/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSchedulesByDate
     *
     * Get scheduled flights
     *
     * @param  \FlightAware\PHPClient\Model\DateStart $date_start Datetime or date of earliest scheduled flight departure to return. This must be no earlier than 3 months in the past and cannot be more than 3 weeks before date_end. Violating either constraint will result in an error. If using date instead of datetime, then the time will default to 00:00:00Z. (required)
     * @param  \FlightAware\PHPClient\Model\DateEnd $date_end Datetime or date of latest scheduled flight departure to return. This must be no later than 1 year in the future and cannot be more than 3 weeks after date_start. Violating either constraint will result in an error. If using date instead of datetime, then the time will default to 00:00:00Z. Thus, the next day&#x27;s date should be specified if one day of data is desired when using date instead of datetime. (required)
     * @param  string $origin Only return flights with this origin airport. ICAO or IATA airport codes can be provided. (optional)
     * @param  string $destination Only return flights with this destination airport. ICAO or IATA airport codes can be provided. (optional)
     * @param  string $airline Only return flights flown by this carrier. ICAO or IATA carrier codes can be provided. (optional)
     * @param  int $flight_number Only return flights with this flight number. (optional)
     * @param  bool $include_codeshares Flag indicating whether ticketing codeshares should be returned as well. (optional, default to true)
     * @param  bool $include_regional Flag indicating whether regional codeshares should be returned as well. (optional, default to true)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20039
     */
    public function getSchedulesByDate($date_start, $date_end, $origin = null, $destination = null, $airline = null, $flight_number = null, $include_codeshares = 'true', $include_regional = 'true', $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getSchedulesByDateWithHttpInfo($date_start, $date_end, $origin, $destination, $airline, $flight_number, $include_codeshares, $include_regional, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getSchedulesByDateWithHttpInfo
     *
     * Get scheduled flights
     *
     * @param  \FlightAware\PHPClient\Model\DateStart $date_start Datetime or date of earliest scheduled flight departure to return. This must be no earlier than 3 months in the past and cannot be more than 3 weeks before date_end. Violating either constraint will result in an error. If using date instead of datetime, then the time will default to 00:00:00Z. (required)
     * @param  \FlightAware\PHPClient\Model\DateEnd $date_end Datetime or date of latest scheduled flight departure to return. This must be no later than 1 year in the future and cannot be more than 3 weeks after date_start. Violating either constraint will result in an error. If using date instead of datetime, then the time will default to 00:00:00Z. Thus, the next day&#x27;s date should be specified if one day of data is desired when using date instead of datetime. (required)
     * @param  string $origin Only return flights with this origin airport. ICAO or IATA airport codes can be provided. (optional)
     * @param  string $destination Only return flights with this destination airport. ICAO or IATA airport codes can be provided. (optional)
     * @param  string $airline Only return flights flown by this carrier. ICAO or IATA carrier codes can be provided. (optional)
     * @param  int $flight_number Only return flights with this flight number. (optional)
     * @param  bool $include_codeshares Flag indicating whether ticketing codeshares should be returned as well. (optional, default to true)
     * @param  bool $include_regional Flag indicating whether regional codeshares should be returned as well. (optional, default to true)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20039, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSchedulesByDateWithHttpInfo($date_start, $date_end, $origin = null, $destination = null, $airline = null, $flight_number = null, $include_codeshares = 'true', $include_regional = 'true', $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20039';
        $request = $this->getSchedulesByDateRequest($date_start, $date_end, $origin, $destination, $airline, $flight_number, $include_codeshares, $include_regional, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20039',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSchedulesByDateAsync
     *
     * Get scheduled flights
     *
     * @param  \FlightAware\PHPClient\Model\DateStart $date_start Datetime or date of earliest scheduled flight departure to return. This must be no earlier than 3 months in the past and cannot be more than 3 weeks before date_end. Violating either constraint will result in an error. If using date instead of datetime, then the time will default to 00:00:00Z. (required)
     * @param  \FlightAware\PHPClient\Model\DateEnd $date_end Datetime or date of latest scheduled flight departure to return. This must be no later than 1 year in the future and cannot be more than 3 weeks after date_start. Violating either constraint will result in an error. If using date instead of datetime, then the time will default to 00:00:00Z. Thus, the next day&#x27;s date should be specified if one day of data is desired when using date instead of datetime. (required)
     * @param  string $origin Only return flights with this origin airport. ICAO or IATA airport codes can be provided. (optional)
     * @param  string $destination Only return flights with this destination airport. ICAO or IATA airport codes can be provided. (optional)
     * @param  string $airline Only return flights flown by this carrier. ICAO or IATA carrier codes can be provided. (optional)
     * @param  int $flight_number Only return flights with this flight number. (optional)
     * @param  bool $include_codeshares Flag indicating whether ticketing codeshares should be returned as well. (optional, default to true)
     * @param  bool $include_regional Flag indicating whether regional codeshares should be returned as well. (optional, default to true)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSchedulesByDateAsync($date_start, $date_end, $origin = null, $destination = null, $airline = null, $flight_number = null, $include_codeshares = 'true', $include_regional = 'true', $max_pages = '1', $cursor = null)
    {
        return $this->getSchedulesByDateAsyncWithHttpInfo($date_start, $date_end, $origin, $destination, $airline, $flight_number, $include_codeshares, $include_regional, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSchedulesByDateAsyncWithHttpInfo
     *
     * Get scheduled flights
     *
     * @param  \FlightAware\PHPClient\Model\DateStart $date_start Datetime or date of earliest scheduled flight departure to return. This must be no earlier than 3 months in the past and cannot be more than 3 weeks before date_end. Violating either constraint will result in an error. If using date instead of datetime, then the time will default to 00:00:00Z. (required)
     * @param  \FlightAware\PHPClient\Model\DateEnd $date_end Datetime or date of latest scheduled flight departure to return. This must be no later than 1 year in the future and cannot be more than 3 weeks after date_start. Violating either constraint will result in an error. If using date instead of datetime, then the time will default to 00:00:00Z. Thus, the next day&#x27;s date should be specified if one day of data is desired when using date instead of datetime. (required)
     * @param  string $origin Only return flights with this origin airport. ICAO or IATA airport codes can be provided. (optional)
     * @param  string $destination Only return flights with this destination airport. ICAO or IATA airport codes can be provided. (optional)
     * @param  string $airline Only return flights flown by this carrier. ICAO or IATA carrier codes can be provided. (optional)
     * @param  int $flight_number Only return flights with this flight number. (optional)
     * @param  bool $include_codeshares Flag indicating whether ticketing codeshares should be returned as well. (optional, default to true)
     * @param  bool $include_regional Flag indicating whether regional codeshares should be returned as well. (optional, default to true)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSchedulesByDateAsyncWithHttpInfo($date_start, $date_end, $origin = null, $destination = null, $airline = null, $flight_number = null, $include_codeshares = 'true', $include_regional = 'true', $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20039';
        $request = $this->getSchedulesByDateRequest($date_start, $date_end, $origin, $destination, $airline, $flight_number, $include_codeshares, $include_regional, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSchedulesByDate'
     *
     * @param  \FlightAware\PHPClient\Model\DateStart $date_start Datetime or date of earliest scheduled flight departure to return. This must be no earlier than 3 months in the past and cannot be more than 3 weeks before date_end. Violating either constraint will result in an error. If using date instead of datetime, then the time will default to 00:00:00Z. (required)
     * @param  \FlightAware\PHPClient\Model\DateEnd $date_end Datetime or date of latest scheduled flight departure to return. This must be no later than 1 year in the future and cannot be more than 3 weeks after date_start. Violating either constraint will result in an error. If using date instead of datetime, then the time will default to 00:00:00Z. Thus, the next day&#x27;s date should be specified if one day of data is desired when using date instead of datetime. (required)
     * @param  string $origin Only return flights with this origin airport. ICAO or IATA airport codes can be provided. (optional)
     * @param  string $destination Only return flights with this destination airport. ICAO or IATA airport codes can be provided. (optional)
     * @param  string $airline Only return flights flown by this carrier. ICAO or IATA carrier codes can be provided. (optional)
     * @param  int $flight_number Only return flights with this flight number. (optional)
     * @param  bool $include_codeshares Flag indicating whether ticketing codeshares should be returned as well. (optional, default to true)
     * @param  bool $include_regional Flag indicating whether regional codeshares should be returned as well. (optional, default to true)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSchedulesByDateRequest($date_start, $date_end, $origin = null, $destination = null, $airline = null, $flight_number = null, $include_codeshares = 'true', $include_regional = 'true', $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'date_start' is set
        if ($date_start === null || (is_array($date_start) && count($date_start) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date_start when calling getSchedulesByDate'
            );
        }
        // verify the required parameter 'date_end' is set
        if ($date_end === null || (is_array($date_end) && count($date_end) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $date_end when calling getSchedulesByDate'
            );
        }

        $resourcePath = '/schedules/{date_start}/{date_end}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($origin !== null) {
            $queryParams['origin'] = ObjectSerializer::toQueryValue($origin, null);
        }
        // query params
        if ($destination !== null) {
            $queryParams['destination'] = ObjectSerializer::toQueryValue($destination, null);
        }
        // query params
        if ($airline !== null) {
            $queryParams['airline'] = ObjectSerializer::toQueryValue($airline, null);
        }
        // query params
        if ($flight_number !== null) {
            $queryParams['flight_number'] = ObjectSerializer::toQueryValue($flight_number, 'int32');
        }
        // query params
        if ($include_codeshares !== null) {
            $queryParams['include_codeshares'] = ObjectSerializer::toQueryValue($include_codeshares, null);
        }
        // query params
        if ($include_regional !== null) {
            $queryParams['include_regional'] = ObjectSerializer::toQueryValue($include_regional, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($date_start !== null) {
            $resourcePath = str_replace(
                '{' . 'date_start' . '}',
                ObjectSerializer::toPathValue($date_start),
                $resourcePath
            );
        }
        // path params
        if ($date_end !== null) {
            $resourcePath = str_replace(
                '{' . 'date_end' . '}',
                ObjectSerializer::toPathValue($date_end),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
