<?php
/**
 * OperatorsApi
 * PHP version 5
 *
 * @category Class
 * @package  FlightAware\PHPClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AeroAPI
 *
 * # Introduction AeroAPI is a simple, query-based API that gives software developers access to a variety of FlightAware's flight data. Users can obtain current or historical data. AeroAPI is a RESTful API delivering accurate and actionable aviation data. With the introduction of Foresight™, customers have access to the data that powers over half of the predictive airline ETAs in the US.  ## Categories AeroAPI is divided into several categories to make things easier to discover. - Flights: Summary information, planned routes, positions and more - Foresight: Flight positions enhanced with FlightAware Foresight™ - Airports: Airport information and FIDS style resources - Operators: Operator information and fleet activity resources - Alerts: Configure flight alerts and delivery destinations - History: Historical flight access for various endpoints - Miscellaneous: Flight disruption, future schedule information, and aircraft owner information  ## Development Tools AeroAPI is defined using the OpenAPI Spec 3.0, which means it can be easily imported into tools like Postman. To get started try importing the API specification using [Postman's instructions](https://learning.postman.com/docs/integrations/available-integrations/working-with-openAPI/). Once imported as a collection only the \"Value\" field under the collection's Authorization tab needs to be populated and saved before making calls.  The AeroAPI OpenAPI specification is located at:\\ https://flightaware.com/commercial/aeroapi/resources/aeroapi-openapi.yml  Our [open source AeroApps project](/aeroapi/portal/resources) provides a small collection of services and sample applications to help you get started.  The Flight Information Display System (FIDS) AeroApp is an example of a multi-tier application using multiple languages and Docker containers. It demonstrates connectivity, data caching, flight presentation, and leveraging flight maps.  The Alerts AeroApp demonstrates the use of AeroAPI to set, edit, and receive alerts in a sample application with a Dockerized Python backend and a React frontend.  Our AeroAPI push notification [testing interface](/commercial/aeroapi/send.rvt) provides a quick and easy way to test the delivery of customized alerts via AeroAPI push.
 *
 * OpenAPI spec version: 4.12
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.42
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace FlightAware\PHPClient\FlightAwarePHPClient;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use FlightAware\PHPClient\ApiException;
use FlightAware\PHPClient\Configuration;
use FlightAware\PHPClient\HeaderSelector;
use FlightAware\PHPClient\ObjectSerializer;

/**
 * OperatorsApi Class Doc Comment
 *
 * @category Class
 * @package  FlightAware\PHPClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class OperatorsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getAllOperators
     *
     * Get all operators.
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20026
     */
    public function getAllOperators($max_pages = '1', $cursor = null)
    {
        list($response) = $this->getAllOperatorsWithHttpInfo($max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getAllOperatorsWithHttpInfo
     *
     * Get all operators.
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20026, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllOperatorsWithHttpInfo($max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20026';
        $request = $this->getAllOperatorsRequest($max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20026',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllOperatorsAsync
     *
     * Get all operators.
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllOperatorsAsync($max_pages = '1', $cursor = null)
    {
        return $this->getAllOperatorsAsyncWithHttpInfo($max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllOperatorsAsyncWithHttpInfo
     *
     * Get all operators.
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllOperatorsAsyncWithHttpInfo($max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20026';
        $request = $this->getAllOperatorsRequest($max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllOperators'
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllOperatorsRequest($max_pages = '1', $cursor = null)
    {

        $resourcePath = '/operators';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOperator
     *
     * Get static information for an operator.
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20027
     */
    public function getOperator($id)
    {
        list($response) = $this->getOperatorWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getOperatorWithHttpInfo
     *
     * Get static information for an operator.
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20027, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOperatorWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20027';
        $request = $this->getOperatorRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20027',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOperatorAsync
     *
     * Get static information for an operator.
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorAsync($id)
    {
        return $this->getOperatorAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOperatorAsyncWithHttpInfo
     *
     * Get static information for an operator.
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorAsyncWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20027';
        $request = $this->getOperatorRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOperator'
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOperatorRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOperator'
            );
        }

        $resourcePath = '/operators/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOperatorFlights
     *
     * Get all of an operator's flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start8 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End8 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20029
     */
    public function getOperatorFlights($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getOperatorFlightsWithHttpInfo($id, $start, $end, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getOperatorFlightsWithHttpInfo
     *
     * Get all of an operator's flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start8 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End8 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20029, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOperatorFlightsWithHttpInfo($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20029';
        $request = $this->getOperatorFlightsRequest($id, $start, $end, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20029',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOperatorFlightsAsync
     *
     * Get all of an operator's flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start8 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End8 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorFlightsAsync($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        return $this->getOperatorFlightsAsyncWithHttpInfo($id, $start, $end, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOperatorFlightsAsyncWithHttpInfo
     *
     * Get all of an operator's flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start8 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End8 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorFlightsAsyncWithHttpInfo($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20029';
        $request = $this->getOperatorFlightsRequest($id, $start, $end, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOperatorFlights'
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start8 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End8 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOperatorFlightsRequest($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOperatorFlights'
            );
        }

        $resourcePath = '/operators/{id}/flights';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, null);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOperatorFlightsArrived
     *
     * Get arrived flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start10 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End10 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20031
     */
    public function getOperatorFlightsArrived($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getOperatorFlightsArrivedWithHttpInfo($id, $start, $end, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getOperatorFlightsArrivedWithHttpInfo
     *
     * Get arrived flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start10 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End10 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20031, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOperatorFlightsArrivedWithHttpInfo($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20031';
        $request = $this->getOperatorFlightsArrivedRequest($id, $start, $end, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20031',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOperatorFlightsArrivedAsync
     *
     * Get arrived flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start10 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End10 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorFlightsArrivedAsync($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        return $this->getOperatorFlightsArrivedAsyncWithHttpInfo($id, $start, $end, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOperatorFlightsArrivedAsyncWithHttpInfo
     *
     * Get arrived flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start10 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End10 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorFlightsArrivedAsyncWithHttpInfo($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20031';
        $request = $this->getOperatorFlightsArrivedRequest($id, $start, $end, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOperatorFlightsArrived'
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start10 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End10 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOperatorFlightsArrivedRequest($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOperatorFlightsArrived'
            );
        }

        $resourcePath = '/operators/{id}/flights/arrivals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, null);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOperatorFlightsCount
     *
     * Get flight counts for operator
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\OperatorFlightCounts
     */
    public function getOperatorFlightsCount($id)
    {
        list($response) = $this->getOperatorFlightsCountWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getOperatorFlightsCountWithHttpInfo
     *
     * Get flight counts for operator
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\OperatorFlightCounts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOperatorFlightsCountWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\OperatorFlightCounts';
        $request = $this->getOperatorFlightsCountRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\OperatorFlightCounts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOperatorFlightsCountAsync
     *
     * Get flight counts for operator
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorFlightsCountAsync($id)
    {
        return $this->getOperatorFlightsCountAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOperatorFlightsCountAsyncWithHttpInfo
     *
     * Get flight counts for operator
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorFlightsCountAsyncWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\OperatorFlightCounts';
        $request = $this->getOperatorFlightsCountRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOperatorFlightsCount'
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOperatorFlightsCountRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOperatorFlightsCount'
            );
        }

        $resourcePath = '/operators/{id}/flights/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOperatorFlightsEnroute
     *
     * Get en route flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start11 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End11 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20032
     */
    public function getOperatorFlightsEnroute($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getOperatorFlightsEnrouteWithHttpInfo($id, $start, $end, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getOperatorFlightsEnrouteWithHttpInfo
     *
     * Get en route flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start11 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End11 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20032, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOperatorFlightsEnrouteWithHttpInfo($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20032';
        $request = $this->getOperatorFlightsEnrouteRequest($id, $start, $end, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20032',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOperatorFlightsEnrouteAsync
     *
     * Get en route flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start11 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End11 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorFlightsEnrouteAsync($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        return $this->getOperatorFlightsEnrouteAsyncWithHttpInfo($id, $start, $end, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOperatorFlightsEnrouteAsyncWithHttpInfo
     *
     * Get en route flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start11 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End11 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorFlightsEnrouteAsyncWithHttpInfo($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20032';
        $request = $this->getOperatorFlightsEnrouteRequest($id, $start, $end, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOperatorFlightsEnroute'
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start11 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End11 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOperatorFlightsEnrouteRequest($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOperatorFlightsEnroute'
            );
        }

        $resourcePath = '/operators/{id}/flights/enroute';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, null);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOperatorFlightsScheduled
     *
     * Get scheduled flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start9 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End9 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20030
     */
    public function getOperatorFlightsScheduled($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getOperatorFlightsScheduledWithHttpInfo($id, $start, $end, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getOperatorFlightsScheduledWithHttpInfo
     *
     * Get scheduled flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start9 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End9 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20030, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOperatorFlightsScheduledWithHttpInfo($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20030';
        $request = $this->getOperatorFlightsScheduledRequest($id, $start, $end, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20030',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOperatorFlightsScheduledAsync
     *
     * Get scheduled flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start9 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End9 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorFlightsScheduledAsync($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        return $this->getOperatorFlightsScheduledAsyncWithHttpInfo($id, $start, $end, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOperatorFlightsScheduledAsyncWithHttpInfo
     *
     * Get scheduled flights
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start9 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End9 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorFlightsScheduledAsyncWithHttpInfo($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20030';
        $request = $this->getOperatorFlightsScheduledRequest($id, $start, $end, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOperatorFlightsScheduled'
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  \FlightAware\PHPClient\Model\Start9 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End9 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOperatorFlightsScheduledRequest($id, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOperatorFlightsScheduled'
            );
        }

        $resourcePath = '/operators/{id}/flights/scheduled';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, null);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOperatorsCanonical
     *
     * Get the canonical code of an operator for API usage.
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  string $country_code An ISO 3166-1 alpha-2 country code. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20028
     */
    public function getOperatorsCanonical($id, $country_code = null)
    {
        list($response) = $this->getOperatorsCanonicalWithHttpInfo($id, $country_code);
        return $response;
    }

    /**
     * Operation getOperatorsCanonicalWithHttpInfo
     *
     * Get the canonical code of an operator for API usage.
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  string $country_code An ISO 3166-1 alpha-2 country code. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20028, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOperatorsCanonicalWithHttpInfo($id, $country_code = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20028';
        $request = $this->getOperatorsCanonicalRequest($id, $country_code);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20028',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOperatorsCanonicalAsync
     *
     * Get the canonical code of an operator for API usage.
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  string $country_code An ISO 3166-1 alpha-2 country code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorsCanonicalAsync($id, $country_code = null)
    {
        return $this->getOperatorsCanonicalAsyncWithHttpInfo($id, $country_code)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOperatorsCanonicalAsyncWithHttpInfo
     *
     * Get the canonical code of an operator for API usage.
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  string $country_code An ISO 3166-1 alpha-2 country code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOperatorsCanonicalAsyncWithHttpInfo($id, $country_code = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20028';
        $request = $this->getOperatorsCanonicalRequest($id, $country_code);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOperatorsCanonical'
     *
     * @param  string $id The ICAO or IATA identifier for an operator. The use of ICAO code is strongly preferred. In the case of non-unique IATA codes the operator with the lexicographically first ICAO code will be returned. (required)
     * @param  string $country_code An ISO 3166-1 alpha-2 country code. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOperatorsCanonicalRequest($id, $country_code = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getOperatorsCanonical'
            );
        }

        $resourcePath = '/operators/{id}/canonical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($country_code !== null) {
            $queryParams['country_code'] = ObjectSerializer::toQueryValue($country_code, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
