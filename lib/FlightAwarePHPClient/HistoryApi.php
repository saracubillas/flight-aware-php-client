<?php
/**
 * HistoryApi
 * PHP version 5
 *
 * @category Class
 * @package  FlightAware\PHPClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AeroAPI
 *
 * # Introduction AeroAPI is a simple, query-based API that gives software developers access to a variety of FlightAware's flight data. Users can obtain current or historical data. AeroAPI is a RESTful API delivering accurate and actionable aviation data. With the introduction of Foresight™, customers have access to the data that powers over half of the predictive airline ETAs in the US.  ## Categories AeroAPI is divided into several categories to make things easier to discover. - Flights: Summary information, planned routes, positions and more - Foresight: Flight positions enhanced with FlightAware Foresight™ - Airports: Airport information and FIDS style resources - Operators: Operator information and fleet activity resources - Alerts: Configure flight alerts and delivery destinations - History: Historical flight access for various endpoints - Miscellaneous: Flight disruption, future schedule information, and aircraft owner information  ## Development Tools AeroAPI is defined using the OpenAPI Spec 3.0, which means it can be easily imported into tools like Postman. To get started try importing the API specification using [Postman's instructions](https://learning.postman.com/docs/integrations/available-integrations/working-with-openAPI/). Once imported as a collection only the \"Value\" field under the collection's Authorization tab needs to be populated and saved before making calls.  The AeroAPI OpenAPI specification is located at:\\ https://flightaware.com/commercial/aeroapi/resources/aeroapi-openapi.yml  Our [open source AeroApps project](/aeroapi/portal/resources) provides a small collection of services and sample applications to help you get started.  The Flight Information Display System (FIDS) AeroApp is an example of a multi-tier application using multiple languages and Docker containers. It demonstrates connectivity, data caching, flight presentation, and leveraging flight maps.  The Alerts AeroApp demonstrates the use of AeroAPI to set, edit, and receive alerts in a sample application with a Dockerized Python backend and a React frontend.  Our AeroAPI push notification [testing interface](/commercial/aeroapi/send.rvt) provides a quick and easy way to test the delivery of customized alerts via AeroAPI push.
 *
 * OpenAPI spec version: 4.12
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.42
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace FlightAware\PHPClient\FlightAwarePHPClient;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use FlightAware\PHPClient\ApiException;
use FlightAware\PHPClient\Configuration;
use FlightAware\PHPClient\HeaderSelector;
use FlightAware\PHPClient\ObjectSerializer;

/**
 * HistoryApi Class Doc Comment
 *
 * @category Class
 * @package  FlightAware\PHPClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class HistoryApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getHistoryAircraftLastFlight
     *
     * Get aircraft's last known flight
     *
     * @param  string $registration The registration number of the aircraft to fetch (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20036
     */
    public function getHistoryAircraftLastFlight($registration)
    {
        list($response) = $this->getHistoryAircraftLastFlightWithHttpInfo($registration);
        return $response;
    }

    /**
     * Operation getHistoryAircraftLastFlightWithHttpInfo
     *
     * Get aircraft's last known flight
     *
     * @param  string $registration The registration number of the aircraft to fetch (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20036, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoryAircraftLastFlightWithHttpInfo($registration)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20036';
        $request = $this->getHistoryAircraftLastFlightRequest($registration);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20036',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoryAircraftLastFlightAsync
     *
     * Get aircraft's last known flight
     *
     * @param  string $registration The registration number of the aircraft to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoryAircraftLastFlightAsync($registration)
    {
        return $this->getHistoryAircraftLastFlightAsyncWithHttpInfo($registration)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoryAircraftLastFlightAsyncWithHttpInfo
     *
     * Get aircraft's last known flight
     *
     * @param  string $registration The registration number of the aircraft to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoryAircraftLastFlightAsyncWithHttpInfo($registration)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20036';
        $request = $this->getHistoryAircraftLastFlightRequest($registration);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoryAircraftLastFlight'
     *
     * @param  string $registration The registration number of the aircraft to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoryAircraftLastFlightRequest($registration)
    {
        // verify the required parameter 'registration' is set
        if ($registration === null || (is_array($registration) && count($registration) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $registration when calling getHistoryAircraftLastFlight'
            );
        }

        $resourcePath = '/history/aircraft/{registration}/last_flight';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($registration !== null) {
            $resourcePath = str_replace(
                '{' . 'registration' . '}',
                ObjectSerializer::toPathValue($registration),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoryFlight
     *
     * Get information for a historical flight
     *
     * @param  string $ident The ident, registration, or fa_flight_id to fetch (required)
     * @param  string $ident_type Type of ident provided in the ident parameter. By default, the passed ident is interpreted as a registration if possible. This parameter can force the ident to be interpreted as a designator instead. (optional)
     * @param  \FlightAware\PHPClient\Model\Start12 $start The starting date range for flight results, comparing against flights&#x27; &#x60;scheduled_out&#x60; field (or &#x60;scheduled_off&#x60; if &#x60;scheduled_out&#x60; is missing). The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must occur on or after 2011-01-01 00:00:00 UTC and cannot be in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End12 $end The ending date range for flight results, comparing against flights&#x27; &#x60;scheduled_out&#x60; field (or &#x60;scheduled_off&#x60; if &#x60;scheduled_out&#x60; is missing). The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must occur after 2011-01-01 00:00:00 UTC and cannot be in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse2003
     */
    public function getHistoryFlight($ident, $ident_type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getHistoryFlightWithHttpInfo($ident, $ident_type, $start, $end, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getHistoryFlightWithHttpInfo
     *
     * Get information for a historical flight
     *
     * @param  string $ident The ident, registration, or fa_flight_id to fetch (required)
     * @param  string $ident_type Type of ident provided in the ident parameter. By default, the passed ident is interpreted as a registration if possible. This parameter can force the ident to be interpreted as a designator instead. (optional)
     * @param  \FlightAware\PHPClient\Model\Start12 $start The starting date range for flight results, comparing against flights&#x27; &#x60;scheduled_out&#x60; field (or &#x60;scheduled_off&#x60; if &#x60;scheduled_out&#x60; is missing). The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must occur on or after 2011-01-01 00:00:00 UTC and cannot be in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End12 $end The ending date range for flight results, comparing against flights&#x27; &#x60;scheduled_out&#x60; field (or &#x60;scheduled_off&#x60; if &#x60;scheduled_out&#x60; is missing). The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must occur after 2011-01-01 00:00:00 UTC and cannot be in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse2003, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoryFlightWithHttpInfo($ident, $ident_type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse2003';
        $request = $this->getHistoryFlightRequest($ident, $ident_type, $start, $end, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse2003',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoryFlightAsync
     *
     * Get information for a historical flight
     *
     * @param  string $ident The ident, registration, or fa_flight_id to fetch (required)
     * @param  string $ident_type Type of ident provided in the ident parameter. By default, the passed ident is interpreted as a registration if possible. This parameter can force the ident to be interpreted as a designator instead. (optional)
     * @param  \FlightAware\PHPClient\Model\Start12 $start The starting date range for flight results, comparing against flights&#x27; &#x60;scheduled_out&#x60; field (or &#x60;scheduled_off&#x60; if &#x60;scheduled_out&#x60; is missing). The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must occur on or after 2011-01-01 00:00:00 UTC and cannot be in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End12 $end The ending date range for flight results, comparing against flights&#x27; &#x60;scheduled_out&#x60; field (or &#x60;scheduled_off&#x60; if &#x60;scheduled_out&#x60; is missing). The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must occur after 2011-01-01 00:00:00 UTC and cannot be in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoryFlightAsync($ident, $ident_type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        return $this->getHistoryFlightAsyncWithHttpInfo($ident, $ident_type, $start, $end, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoryFlightAsyncWithHttpInfo
     *
     * Get information for a historical flight
     *
     * @param  string $ident The ident, registration, or fa_flight_id to fetch (required)
     * @param  string $ident_type Type of ident provided in the ident parameter. By default, the passed ident is interpreted as a registration if possible. This parameter can force the ident to be interpreted as a designator instead. (optional)
     * @param  \FlightAware\PHPClient\Model\Start12 $start The starting date range for flight results, comparing against flights&#x27; &#x60;scheduled_out&#x60; field (or &#x60;scheduled_off&#x60; if &#x60;scheduled_out&#x60; is missing). The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must occur on or after 2011-01-01 00:00:00 UTC and cannot be in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End12 $end The ending date range for flight results, comparing against flights&#x27; &#x60;scheduled_out&#x60; field (or &#x60;scheduled_off&#x60; if &#x60;scheduled_out&#x60; is missing). The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must occur after 2011-01-01 00:00:00 UTC and cannot be in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoryFlightAsyncWithHttpInfo($ident, $ident_type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse2003';
        $request = $this->getHistoryFlightRequest($ident, $ident_type, $start, $end, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoryFlight'
     *
     * @param  string $ident The ident, registration, or fa_flight_id to fetch (required)
     * @param  string $ident_type Type of ident provided in the ident parameter. By default, the passed ident is interpreted as a registration if possible. This parameter can force the ident to be interpreted as a designator instead. (optional)
     * @param  \FlightAware\PHPClient\Model\Start12 $start The starting date range for flight results, comparing against flights&#x27; &#x60;scheduled_out&#x60; field (or &#x60;scheduled_off&#x60; if &#x60;scheduled_out&#x60; is missing). The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must occur on or after 2011-01-01 00:00:00 UTC and cannot be in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End12 $end The ending date range for flight results, comparing against flights&#x27; &#x60;scheduled_out&#x60; field (or &#x60;scheduled_off&#x60; if &#x60;scheduled_out&#x60; is missing). The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must occur after 2011-01-01 00:00:00 UTC and cannot be in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoryFlightRequest($ident, $ident_type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'ident' is set
        if ($ident === null || (is_array($ident) && count($ident) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ident when calling getHistoryFlight'
            );
        }

        $resourcePath = '/history/flights/{ident}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ident_type !== null) {
            $queryParams['ident_type'] = ObjectSerializer::toQueryValue($ident_type, null);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, null);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($ident !== null) {
            $resourcePath = str_replace(
                '{' . 'ident' . '}',
                ObjectSerializer::toPathValue($ident),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoryFlightMap
     *
     * Get an image of a historical flight's track on a map
     *
     * @param  string $id The fa_flight_id to fetch (required)
     * @param  int $height Height of requested image (pixels) (optional, default to 480)
     * @param  int $width Width of requested image (pixels) (optional, default to 640)
     * @param  string[] $layer_on List of map layers to enable (optional, default to ["country boundaries","US state boundaries","water","US major roads","radar","track","flights","airports"])
     * @param  string[] $layer_off List of map layers to disable (optional, default to ["US Cities","european country boundaries","asia country boundaries","major airports"])
     * @param  bool $show_data_block Whether a textual caption containing the ident, type, heading, altitude, origin, and destination should be displayed by the flight&#x27;s position. (optional, default to false)
     * @param  bool $airports_expand_view Whether to force zoom area to ensure origin/destination airports are visible. Enabling this flag forcefully enables the show_airports flag as well. (optional, default to false)
     * @param  bool $show_airports Whether to show the origin/destination airports for the flight as labeled points on the map. (optional, default to false)
     * @param  float[] $bounding_box Manually specify the zoom area of the map using custom bounds. Should be a list of 4 coordinates representing the top, right, bottom, and left sides of the area (in that order). (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse2008
     */
    public function getHistoryFlightMap($id, $height = '480', $width = '640', $layer_on = '["country boundaries","US state boundaries","water","US major roads","radar","track","flights","airports"]', $layer_off = '["US Cities","european country boundaries","asia country boundaries","major airports"]', $show_data_block = 'false', $airports_expand_view = 'false', $show_airports = 'false', $bounding_box = null)
    {
        list($response) = $this->getHistoryFlightMapWithHttpInfo($id, $height, $width, $layer_on, $layer_off, $show_data_block, $airports_expand_view, $show_airports, $bounding_box);
        return $response;
    }

    /**
     * Operation getHistoryFlightMapWithHttpInfo
     *
     * Get an image of a historical flight's track on a map
     *
     * @param  string $id The fa_flight_id to fetch (required)
     * @param  int $height Height of requested image (pixels) (optional, default to 480)
     * @param  int $width Width of requested image (pixels) (optional, default to 640)
     * @param  string[] $layer_on List of map layers to enable (optional, default to ["country boundaries","US state boundaries","water","US major roads","radar","track","flights","airports"])
     * @param  string[] $layer_off List of map layers to disable (optional, default to ["US Cities","european country boundaries","asia country boundaries","major airports"])
     * @param  bool $show_data_block Whether a textual caption containing the ident, type, heading, altitude, origin, and destination should be displayed by the flight&#x27;s position. (optional, default to false)
     * @param  bool $airports_expand_view Whether to force zoom area to ensure origin/destination airports are visible. Enabling this flag forcefully enables the show_airports flag as well. (optional, default to false)
     * @param  bool $show_airports Whether to show the origin/destination airports for the flight as labeled points on the map. (optional, default to false)
     * @param  float[] $bounding_box Manually specify the zoom area of the map using custom bounds. Should be a list of 4 coordinates representing the top, right, bottom, and left sides of the area (in that order). (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse2008, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoryFlightMapWithHttpInfo($id, $height = '480', $width = '640', $layer_on = '["country boundaries","US state boundaries","water","US major roads","radar","track","flights","airports"]', $layer_off = '["US Cities","european country boundaries","asia country boundaries","major airports"]', $show_data_block = 'false', $airports_expand_view = 'false', $show_airports = 'false', $bounding_box = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse2008';
        $request = $this->getHistoryFlightMapRequest($id, $height, $width, $layer_on, $layer_off, $show_data_block, $airports_expand_view, $show_airports, $bounding_box);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse2008',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoryFlightMapAsync
     *
     * Get an image of a historical flight's track on a map
     *
     * @param  string $id The fa_flight_id to fetch (required)
     * @param  int $height Height of requested image (pixels) (optional, default to 480)
     * @param  int $width Width of requested image (pixels) (optional, default to 640)
     * @param  string[] $layer_on List of map layers to enable (optional, default to ["country boundaries","US state boundaries","water","US major roads","radar","track","flights","airports"])
     * @param  string[] $layer_off List of map layers to disable (optional, default to ["US Cities","european country boundaries","asia country boundaries","major airports"])
     * @param  bool $show_data_block Whether a textual caption containing the ident, type, heading, altitude, origin, and destination should be displayed by the flight&#x27;s position. (optional, default to false)
     * @param  bool $airports_expand_view Whether to force zoom area to ensure origin/destination airports are visible. Enabling this flag forcefully enables the show_airports flag as well. (optional, default to false)
     * @param  bool $show_airports Whether to show the origin/destination airports for the flight as labeled points on the map. (optional, default to false)
     * @param  float[] $bounding_box Manually specify the zoom area of the map using custom bounds. Should be a list of 4 coordinates representing the top, right, bottom, and left sides of the area (in that order). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoryFlightMapAsync($id, $height = '480', $width = '640', $layer_on = '["country boundaries","US state boundaries","water","US major roads","radar","track","flights","airports"]', $layer_off = '["US Cities","european country boundaries","asia country boundaries","major airports"]', $show_data_block = 'false', $airports_expand_view = 'false', $show_airports = 'false', $bounding_box = null)
    {
        return $this->getHistoryFlightMapAsyncWithHttpInfo($id, $height, $width, $layer_on, $layer_off, $show_data_block, $airports_expand_view, $show_airports, $bounding_box)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoryFlightMapAsyncWithHttpInfo
     *
     * Get an image of a historical flight's track on a map
     *
     * @param  string $id The fa_flight_id to fetch (required)
     * @param  int $height Height of requested image (pixels) (optional, default to 480)
     * @param  int $width Width of requested image (pixels) (optional, default to 640)
     * @param  string[] $layer_on List of map layers to enable (optional, default to ["country boundaries","US state boundaries","water","US major roads","radar","track","flights","airports"])
     * @param  string[] $layer_off List of map layers to disable (optional, default to ["US Cities","european country boundaries","asia country boundaries","major airports"])
     * @param  bool $show_data_block Whether a textual caption containing the ident, type, heading, altitude, origin, and destination should be displayed by the flight&#x27;s position. (optional, default to false)
     * @param  bool $airports_expand_view Whether to force zoom area to ensure origin/destination airports are visible. Enabling this flag forcefully enables the show_airports flag as well. (optional, default to false)
     * @param  bool $show_airports Whether to show the origin/destination airports for the flight as labeled points on the map. (optional, default to false)
     * @param  float[] $bounding_box Manually specify the zoom area of the map using custom bounds. Should be a list of 4 coordinates representing the top, right, bottom, and left sides of the area (in that order). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoryFlightMapAsyncWithHttpInfo($id, $height = '480', $width = '640', $layer_on = '["country boundaries","US state boundaries","water","US major roads","radar","track","flights","airports"]', $layer_off = '["US Cities","european country boundaries","asia country boundaries","major airports"]', $show_data_block = 'false', $airports_expand_view = 'false', $show_airports = 'false', $bounding_box = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse2008';
        $request = $this->getHistoryFlightMapRequest($id, $height, $width, $layer_on, $layer_off, $show_data_block, $airports_expand_view, $show_airports, $bounding_box);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoryFlightMap'
     *
     * @param  string $id The fa_flight_id to fetch (required)
     * @param  int $height Height of requested image (pixels) (optional, default to 480)
     * @param  int $width Width of requested image (pixels) (optional, default to 640)
     * @param  string[] $layer_on List of map layers to enable (optional, default to ["country boundaries","US state boundaries","water","US major roads","radar","track","flights","airports"])
     * @param  string[] $layer_off List of map layers to disable (optional, default to ["US Cities","european country boundaries","asia country boundaries","major airports"])
     * @param  bool $show_data_block Whether a textual caption containing the ident, type, heading, altitude, origin, and destination should be displayed by the flight&#x27;s position. (optional, default to false)
     * @param  bool $airports_expand_view Whether to force zoom area to ensure origin/destination airports are visible. Enabling this flag forcefully enables the show_airports flag as well. (optional, default to false)
     * @param  bool $show_airports Whether to show the origin/destination airports for the flight as labeled points on the map. (optional, default to false)
     * @param  float[] $bounding_box Manually specify the zoom area of the map using custom bounds. Should be a list of 4 coordinates representing the top, right, bottom, and left sides of the area (in that order). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoryFlightMapRequest($id, $height = '480', $width = '640', $layer_on = '["country boundaries","US state boundaries","water","US major roads","radar","track","flights","airports"]', $layer_off = '["US Cities","european country boundaries","asia country boundaries","major airports"]', $show_data_block = 'false', $airports_expand_view = 'false', $show_airports = 'false', $bounding_box = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getHistoryFlightMap'
            );
        }

        $resourcePath = '/history/flights/{id}/map';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($height !== null) {
            $queryParams['height'] = ObjectSerializer::toQueryValue($height, null);
        }
        // query params
        if ($width !== null) {
            $queryParams['width'] = ObjectSerializer::toQueryValue($width, null);
        }
        // query params
        if (is_array($layer_on)) {
            $layer_on = ObjectSerializer::serializeCollection($layer_on, 'multi', true);
        }
        if ($layer_on !== null) {
            $queryParams['layer_on'] = ObjectSerializer::toQueryValue($layer_on, null);
        }
        // query params
        if (is_array($layer_off)) {
            $layer_off = ObjectSerializer::serializeCollection($layer_off, 'multi', true);
        }
        if ($layer_off !== null) {
            $queryParams['layer_off'] = ObjectSerializer::toQueryValue($layer_off, null);
        }
        // query params
        if ($show_data_block !== null) {
            $queryParams['show_data_block'] = ObjectSerializer::toQueryValue($show_data_block, null);
        }
        // query params
        if ($airports_expand_view !== null) {
            $queryParams['airports_expand_view'] = ObjectSerializer::toQueryValue($airports_expand_view, null);
        }
        // query params
        if ($show_airports !== null) {
            $queryParams['show_airports'] = ObjectSerializer::toQueryValue($show_airports, null);
        }
        // query params
        if (is_array($bounding_box)) {
            $bounding_box = ObjectSerializer::serializeCollection($bounding_box, 'multi', true);
        }
        if ($bounding_box !== null) {
            $queryParams['bounding_box'] = ObjectSerializer::toQueryValue($bounding_box, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoryFlightRoute
     *
     * Get historical flight's filed route
     *
     * @param  string $id The fa_flight_id to fetch (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse2007
     */
    public function getHistoryFlightRoute($id)
    {
        list($response) = $this->getHistoryFlightRouteWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getHistoryFlightRouteWithHttpInfo
     *
     * Get historical flight's filed route
     *
     * @param  string $id The fa_flight_id to fetch (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse2007, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoryFlightRouteWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse2007';
        $request = $this->getHistoryFlightRouteRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse2007',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoryFlightRouteAsync
     *
     * Get historical flight's filed route
     *
     * @param  string $id The fa_flight_id to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoryFlightRouteAsync($id)
    {
        return $this->getHistoryFlightRouteAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoryFlightRouteAsyncWithHttpInfo
     *
     * Get historical flight's filed route
     *
     * @param  string $id The fa_flight_id to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoryFlightRouteAsyncWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse2007';
        $request = $this->getHistoryFlightRouteRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoryFlightRoute'
     *
     * @param  string $id The fa_flight_id to fetch (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoryFlightRouteRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getHistoryFlightRoute'
            );
        }

        $resourcePath = '/history/flights/{id}/route';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getHistoryFlightTrack
     *
     * Get historical information for a flight's track
     *
     * @param  string $id The fa_flight_id to fetch (required)
     * @param  bool $include_estimated_positions Whether to include estimated positions in the flight track (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse2006
     */
    public function getHistoryFlightTrack($id, $include_estimated_positions = null)
    {
        list($response) = $this->getHistoryFlightTrackWithHttpInfo($id, $include_estimated_positions);
        return $response;
    }

    /**
     * Operation getHistoryFlightTrackWithHttpInfo
     *
     * Get historical information for a flight's track
     *
     * @param  string $id The fa_flight_id to fetch (required)
     * @param  bool $include_estimated_positions Whether to include estimated positions in the flight track (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse2006, HTTP status code, HTTP response headers (array of strings)
     */
    public function getHistoryFlightTrackWithHttpInfo($id, $include_estimated_positions = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse2006';
        $request = $this->getHistoryFlightTrackRequest($id, $include_estimated_positions);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse2006',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getHistoryFlightTrackAsync
     *
     * Get historical information for a flight's track
     *
     * @param  string $id The fa_flight_id to fetch (required)
     * @param  bool $include_estimated_positions Whether to include estimated positions in the flight track (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoryFlightTrackAsync($id, $include_estimated_positions = null)
    {
        return $this->getHistoryFlightTrackAsyncWithHttpInfo($id, $include_estimated_positions)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getHistoryFlightTrackAsyncWithHttpInfo
     *
     * Get historical information for a flight's track
     *
     * @param  string $id The fa_flight_id to fetch (required)
     * @param  bool $include_estimated_positions Whether to include estimated positions in the flight track (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getHistoryFlightTrackAsyncWithHttpInfo($id, $include_estimated_positions = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse2006';
        $request = $this->getHistoryFlightTrackRequest($id, $include_estimated_positions);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getHistoryFlightTrack'
     *
     * @param  string $id The fa_flight_id to fetch (required)
     * @param  bool $include_estimated_positions Whether to include estimated positions in the flight track (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getHistoryFlightTrackRequest($id, $include_estimated_positions = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getHistoryFlightTrack'
            );
        }

        $resourcePath = '/history/flights/{id}/track';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_estimated_positions !== null) {
            $queryParams['include_estimated_positions'] = ObjectSerializer::toQueryValue($include_estimated_positions, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
