<?php
/**
 * AirportsApi
 * PHP version 5
 *
 * @category Class
 * @package  FlightAware\PHPClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * AeroAPI
 *
 * # Introduction AeroAPI is a simple, query-based API that gives software developers access to a variety of FlightAware's flight data. Users can obtain current or historical data. AeroAPI is a RESTful API delivering accurate and actionable aviation data. With the introduction of Foresight™, customers have access to the data that powers over half of the predictive airline ETAs in the US.  ## Categories AeroAPI is divided into several categories to make things easier to discover. - Flights: Summary information, planned routes, positions and more - Foresight: Flight positions enhanced with FlightAware Foresight™ - Airports: Airport information and FIDS style resources - Operators: Operator information and fleet activity resources - Alerts: Configure flight alerts and delivery destinations - History: Historical flight access for various endpoints - Miscellaneous: Flight disruption, future schedule information, and aircraft owner information  ## Development Tools AeroAPI is defined using the OpenAPI Spec 3.0, which means it can be easily imported into tools like Postman. To get started try importing the API specification using [Postman's instructions](https://learning.postman.com/docs/integrations/available-integrations/working-with-openAPI/). Once imported as a collection only the \"Value\" field under the collection's Authorization tab needs to be populated and saved before making calls.  The AeroAPI OpenAPI specification is located at:\\ https://flightaware.com/commercial/aeroapi/resources/aeroapi-openapi.yml  Our [open source AeroApps project](/aeroapi/portal/resources) provides a small collection of services and sample applications to help you get started.  The Flight Information Display System (FIDS) AeroApp is an example of a multi-tier application using multiple languages and Docker containers. It demonstrates connectivity, data caching, flight presentation, and leveraging flight maps.  The Alerts AeroApp demonstrates the use of AeroAPI to set, edit, and receive alerts in a sample application with a Dockerized Python backend and a React frontend.  Our AeroAPI push notification [testing interface](/commercial/aeroapi/send.rvt) provides a quick and easy way to test the delivery of customized alerts via AeroAPI push.
 *
 * OpenAPI spec version: 4.12
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.42
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace FlightAware\PHPClient\FlightAwarePHPClient;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use FlightAware\PHPClient\ApiException;
use FlightAware\PHPClient\Configuration;
use FlightAware\PHPClient\HeaderSelector;
use FlightAware\PHPClient\ObjectSerializer;

/**
 * AirportsApi Class Doc Comment
 *
 * @category Class
 * @package  FlightAware\PHPClient
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AirportsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getAirport
     *
     * Get static information about an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20015
     */
    public function getAirport($id)
    {
        list($response) = $this->getAirportWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getAirportWithHttpInfo
     *
     * Get static information about an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20015, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20015';
        $request = $this->getAirportRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20015',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportAsync
     *
     * Get static information about an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportAsync($id)
    {
        return $this->getAirportAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportAsyncWithHttpInfo
     *
     * Get static information about an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportAsyncWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20015';
        $request = $this->getAirportRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirport'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirport'
            );
        }

        $resourcePath = '/airports/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAirportDelays
     *
     * Get airport delay information
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\AirportDelay
     */
    public function getAirportDelays($id)
    {
        list($response) = $this->getAirportDelaysWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getAirportDelaysWithHttpInfo
     *
     * Get airport delay information
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\AirportDelay, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportDelaysWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\AirportDelay';
        $request = $this->getAirportDelaysRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\AirportDelay',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportDelaysAsync
     *
     * Get airport delay information
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportDelaysAsync($id)
    {
        return $this->getAirportDelaysAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportDelaysAsyncWithHttpInfo
     *
     * Get airport delay information
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportDelaysAsyncWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\AirportDelay';
        $request = $this->getAirportDelaysRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirportDelays'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportDelaysRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirportDelays'
            );
        }

        $resourcePath = '/airports/{id}/delays';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAirportFlights
     *
     * Get all flights for a given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start2 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End2 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20018
     */
    public function getAirportFlights($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getAirportFlightsWithHttpInfo($id, $airline, $type, $start, $end, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getAirportFlightsWithHttpInfo
     *
     * Get all flights for a given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start2 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End2 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20018, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportFlightsWithHttpInfo($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20018';
        $request = $this->getAirportFlightsRequest($id, $airline, $type, $start, $end, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20018',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportFlightsAsync
     *
     * Get all flights for a given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start2 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End2 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsAsync($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        return $this->getAirportFlightsAsyncWithHttpInfo($id, $airline, $type, $start, $end, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportFlightsAsyncWithHttpInfo
     *
     * Get all flights for a given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start2 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End2 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsAsyncWithHttpInfo($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20018';
        $request = $this->getAirportFlightsRequest($id, $airline, $type, $start, $end, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirportFlights'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start2 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End2 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportFlightsRequest($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirportFlights'
            );
        }

        $resourcePath = '/airports/{id}/flights';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($airline !== null) {
            $queryParams['airline'] = ObjectSerializer::toQueryValue($airline, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, null);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAirportFlightsArrived
     *
     * Get flights that have recently arrived at an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start3 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End3 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20019
     */
    public function getAirportFlightsArrived($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getAirportFlightsArrivedWithHttpInfo($id, $airline, $type, $start, $end, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getAirportFlightsArrivedWithHttpInfo
     *
     * Get flights that have recently arrived at an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start3 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End3 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20019, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportFlightsArrivedWithHttpInfo($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20019';
        $request = $this->getAirportFlightsArrivedRequest($id, $airline, $type, $start, $end, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20019',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportFlightsArrivedAsync
     *
     * Get flights that have recently arrived at an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start3 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End3 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsArrivedAsync($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        return $this->getAirportFlightsArrivedAsyncWithHttpInfo($id, $airline, $type, $start, $end, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportFlightsArrivedAsyncWithHttpInfo
     *
     * Get flights that have recently arrived at an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start3 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End3 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsArrivedAsyncWithHttpInfo($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20019';
        $request = $this->getAirportFlightsArrivedRequest($id, $airline, $type, $start, $end, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirportFlightsArrived'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start3 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End3 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportFlightsArrivedRequest($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirportFlightsArrived'
            );
        }

        $resourcePath = '/airports/{id}/flights/arrivals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($airline !== null) {
            $queryParams['airline'] = ObjectSerializer::toQueryValue($airline, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, null);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAirportFlightsCount
     *
     * Get flight counts for an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\AirportFlightCounts
     */
    public function getAirportFlightsCount($id)
    {
        list($response) = $this->getAirportFlightsCountWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getAirportFlightsCountWithHttpInfo
     *
     * Get flight counts for an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\AirportFlightCounts, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportFlightsCountWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\AirportFlightCounts';
        $request = $this->getAirportFlightsCountRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\AirportFlightCounts',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportFlightsCountAsync
     *
     * Get flight counts for an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsCountAsync($id)
    {
        return $this->getAirportFlightsCountAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportFlightsCountAsyncWithHttpInfo
     *
     * Get flight counts for an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsCountAsyncWithHttpInfo($id)
    {
        $returnType = '\FlightAware\PHPClient\Model\AirportFlightCounts';
        $request = $this->getAirportFlightsCountRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirportFlightsCount'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportFlightsCountRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirportFlightsCount'
            );
        }

        $resourcePath = '/airports/{id}/flights/counts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAirportFlightsDeparted
     *
     * Get flights that have recently departed from an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start4 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End4 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20020
     */
    public function getAirportFlightsDeparted($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getAirportFlightsDepartedWithHttpInfo($id, $airline, $type, $start, $end, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getAirportFlightsDepartedWithHttpInfo
     *
     * Get flights that have recently departed from an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start4 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End4 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20020, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportFlightsDepartedWithHttpInfo($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20020';
        $request = $this->getAirportFlightsDepartedRequest($id, $airline, $type, $start, $end, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20020',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportFlightsDepartedAsync
     *
     * Get flights that have recently departed from an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start4 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End4 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsDepartedAsync($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        return $this->getAirportFlightsDepartedAsyncWithHttpInfo($id, $airline, $type, $start, $end, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportFlightsDepartedAsyncWithHttpInfo
     *
     * Get flights that have recently departed from an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start4 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End4 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsDepartedAsyncWithHttpInfo($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20020';
        $request = $this->getAirportFlightsDepartedRequest($id, $airline, $type, $start, $end, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirportFlightsDeparted'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start4 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End4 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportFlightsDepartedRequest($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirportFlightsDeparted'
            );
        }

        $resourcePath = '/airports/{id}/flights/departures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($airline !== null) {
            $queryParams['airline'] = ObjectSerializer::toQueryValue($airline, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, null);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAirportFlightsScheduledArrivals
     *
     * Get future flights arriving at an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start6 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End6 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20022
     */
    public function getAirportFlightsScheduledArrivals($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getAirportFlightsScheduledArrivalsWithHttpInfo($id, $airline, $type, $start, $end, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getAirportFlightsScheduledArrivalsWithHttpInfo
     *
     * Get future flights arriving at an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start6 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End6 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20022, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportFlightsScheduledArrivalsWithHttpInfo($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20022';
        $request = $this->getAirportFlightsScheduledArrivalsRequest($id, $airline, $type, $start, $end, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20022',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportFlightsScheduledArrivalsAsync
     *
     * Get future flights arriving at an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start6 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End6 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsScheduledArrivalsAsync($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        return $this->getAirportFlightsScheduledArrivalsAsyncWithHttpInfo($id, $airline, $type, $start, $end, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportFlightsScheduledArrivalsAsyncWithHttpInfo
     *
     * Get future flights arriving at an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start6 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End6 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsScheduledArrivalsAsyncWithHttpInfo($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20022';
        $request = $this->getAirportFlightsScheduledArrivalsRequest($id, $airline, $type, $start, $end, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirportFlightsScheduledArrivals'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start6 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End6 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportFlightsScheduledArrivalsRequest($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirportFlightsScheduledArrivals'
            );
        }

        $resourcePath = '/airports/{id}/flights/scheduled_arrivals';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($airline !== null) {
            $queryParams['airline'] = ObjectSerializer::toQueryValue($airline, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, null);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAirportFlightsScheduledDepartures
     *
     * Get future flights departing from an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start5 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End5 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20021
     */
    public function getAirportFlightsScheduledDepartures($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getAirportFlightsScheduledDeparturesWithHttpInfo($id, $airline, $type, $start, $end, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getAirportFlightsScheduledDeparturesWithHttpInfo
     *
     * Get future flights departing from an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start5 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End5 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20021, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportFlightsScheduledDeparturesWithHttpInfo($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20021';
        $request = $this->getAirportFlightsScheduledDeparturesRequest($id, $airline, $type, $start, $end, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20021',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportFlightsScheduledDeparturesAsync
     *
     * Get future flights departing from an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start5 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End5 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsScheduledDeparturesAsync($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        return $this->getAirportFlightsScheduledDeparturesAsyncWithHttpInfo($id, $airline, $type, $start, $end, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportFlightsScheduledDeparturesAsyncWithHttpInfo
     *
     * Get future flights departing from an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start5 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End5 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportFlightsScheduledDeparturesAsyncWithHttpInfo($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20021';
        $request = $this->getAirportFlightsScheduledDeparturesRequest($id, $airline, $type, $start, $end, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirportFlightsScheduledDepartures'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $airline Airline to filter flights by. Do not provide airline if type is provided. (optional)
     * @param  string $type Type of flights to return. Do not provide type if airline is provided. (optional)
     * @param  \FlightAware\PHPClient\Model\Start5 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End5 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportFlightsScheduledDeparturesRequest($id, $airline = null, $type = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirportFlightsScheduledDepartures'
            );
        }

        $resourcePath = '/airports/{id}/flights/scheduled_departures';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($airline !== null) {
            $queryParams['airline'] = ObjectSerializer::toQueryValue($airline, null);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, null);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAirportWeatherForecast
     *
     * Get weather forecast for given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  \DateTime $timestamp Timestamp from which to begin returning weather data in a 1 day range. Because weather data is returned in reverse chronological order, all returned weather reports will be from before this timestamp. If unspecified, weather is returned starting from now up to or less than the user history limit, normally 14 days. (optional)
     * @param  bool $return_nearby_weather If the requested airport does not have a weather conditions report then the weather for the nearest airport within 30 miles will be returned instead. (optional, default to false)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\WeatherForecast
     */
    public function getAirportWeatherForecast($id, $timestamp = null, $return_nearby_weather = 'false')
    {
        list($response) = $this->getAirportWeatherForecastWithHttpInfo($id, $timestamp, $return_nearby_weather);
        return $response;
    }

    /**
     * Operation getAirportWeatherForecastWithHttpInfo
     *
     * Get weather forecast for given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  \DateTime $timestamp Timestamp from which to begin returning weather data in a 1 day range. Because weather data is returned in reverse chronological order, all returned weather reports will be from before this timestamp. If unspecified, weather is returned starting from now up to or less than the user history limit, normally 14 days. (optional)
     * @param  bool $return_nearby_weather If the requested airport does not have a weather conditions report then the weather for the nearest airport within 30 miles will be returned instead. (optional, default to false)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\WeatherForecast, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportWeatherForecastWithHttpInfo($id, $timestamp = null, $return_nearby_weather = 'false')
    {
        $returnType = '\FlightAware\PHPClient\Model\WeatherForecast';
        $request = $this->getAirportWeatherForecastRequest($id, $timestamp, $return_nearby_weather);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\WeatherForecast',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportWeatherForecastAsync
     *
     * Get weather forecast for given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  \DateTime $timestamp Timestamp from which to begin returning weather data in a 1 day range. Because weather data is returned in reverse chronological order, all returned weather reports will be from before this timestamp. If unspecified, weather is returned starting from now up to or less than the user history limit, normally 14 days. (optional)
     * @param  bool $return_nearby_weather If the requested airport does not have a weather conditions report then the weather for the nearest airport within 30 miles will be returned instead. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportWeatherForecastAsync($id, $timestamp = null, $return_nearby_weather = 'false')
    {
        return $this->getAirportWeatherForecastAsyncWithHttpInfo($id, $timestamp, $return_nearby_weather)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportWeatherForecastAsyncWithHttpInfo
     *
     * Get weather forecast for given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  \DateTime $timestamp Timestamp from which to begin returning weather data in a 1 day range. Because weather data is returned in reverse chronological order, all returned weather reports will be from before this timestamp. If unspecified, weather is returned starting from now up to or less than the user history limit, normally 14 days. (optional)
     * @param  bool $return_nearby_weather If the requested airport does not have a weather conditions report then the weather for the nearest airport within 30 miles will be returned instead. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportWeatherForecastAsyncWithHttpInfo($id, $timestamp = null, $return_nearby_weather = 'false')
    {
        $returnType = '\FlightAware\PHPClient\Model\WeatherForecast';
        $request = $this->getAirportWeatherForecastRequest($id, $timestamp, $return_nearby_weather);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirportWeatherForecast'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  \DateTime $timestamp Timestamp from which to begin returning weather data in a 1 day range. Because weather data is returned in reverse chronological order, all returned weather reports will be from before this timestamp. If unspecified, weather is returned starting from now up to or less than the user history limit, normally 14 days. (optional)
     * @param  bool $return_nearby_weather If the requested airport does not have a weather conditions report then the weather for the nearest airport within 30 miles will be returned instead. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportWeatherForecastRequest($id, $timestamp = null, $return_nearby_weather = 'false')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirportWeatherForecast'
            );
        }

        $resourcePath = '/airports/{id}/weather/forecast';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($timestamp !== null) {
            $queryParams['timestamp'] = ObjectSerializer::toQueryValue($timestamp, 'date-time');
        }
        // query params
        if ($return_nearby_weather !== null) {
            $queryParams['return_nearby_weather'] = ObjectSerializer::toQueryValue($return_nearby_weather, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAirportWeatherObservations
     *
     * Get weather conditions for given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $temperature_units Units to use for temperature fields. (optional, default to Celsius)
     * @param  bool $return_nearby_weather If the requested airport does not have a weather conditions report then the weather for the nearest airport within 30 miles will be returned instead. (optional, default to false)
     * @param  \DateTime $timestamp Timestamp from which to begin returning weather data in a 1 day range. Because weather data is returned in reverse chronological order, all returned weather reports will be from before this timestamp. If unspecified, weather is returned starting from now up to or less than the user history limit, normally 14 days. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20024
     */
    public function getAirportWeatherObservations($id, $temperature_units = 'Celsius', $return_nearby_weather = 'false', $timestamp = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getAirportWeatherObservationsWithHttpInfo($id, $temperature_units, $return_nearby_weather, $timestamp, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getAirportWeatherObservationsWithHttpInfo
     *
     * Get weather conditions for given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $temperature_units Units to use for temperature fields. (optional, default to Celsius)
     * @param  bool $return_nearby_weather If the requested airport does not have a weather conditions report then the weather for the nearest airport within 30 miles will be returned instead. (optional, default to false)
     * @param  \DateTime $timestamp Timestamp from which to begin returning weather data in a 1 day range. Because weather data is returned in reverse chronological order, all returned weather reports will be from before this timestamp. If unspecified, weather is returned starting from now up to or less than the user history limit, normally 14 days. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20024, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportWeatherObservationsWithHttpInfo($id, $temperature_units = 'Celsius', $return_nearby_weather = 'false', $timestamp = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20024';
        $request = $this->getAirportWeatherObservationsRequest($id, $temperature_units, $return_nearby_weather, $timestamp, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20024',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportWeatherObservationsAsync
     *
     * Get weather conditions for given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $temperature_units Units to use for temperature fields. (optional, default to Celsius)
     * @param  bool $return_nearby_weather If the requested airport does not have a weather conditions report then the weather for the nearest airport within 30 miles will be returned instead. (optional, default to false)
     * @param  \DateTime $timestamp Timestamp from which to begin returning weather data in a 1 day range. Because weather data is returned in reverse chronological order, all returned weather reports will be from before this timestamp. If unspecified, weather is returned starting from now up to or less than the user history limit, normally 14 days. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportWeatherObservationsAsync($id, $temperature_units = 'Celsius', $return_nearby_weather = 'false', $timestamp = null, $max_pages = '1', $cursor = null)
    {
        return $this->getAirportWeatherObservationsAsyncWithHttpInfo($id, $temperature_units, $return_nearby_weather, $timestamp, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportWeatherObservationsAsyncWithHttpInfo
     *
     * Get weather conditions for given airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $temperature_units Units to use for temperature fields. (optional, default to Celsius)
     * @param  bool $return_nearby_weather If the requested airport does not have a weather conditions report then the weather for the nearest airport within 30 miles will be returned instead. (optional, default to false)
     * @param  \DateTime $timestamp Timestamp from which to begin returning weather data in a 1 day range. Because weather data is returned in reverse chronological order, all returned weather reports will be from before this timestamp. If unspecified, weather is returned starting from now up to or less than the user history limit, normally 14 days. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportWeatherObservationsAsyncWithHttpInfo($id, $temperature_units = 'Celsius', $return_nearby_weather = 'false', $timestamp = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20024';
        $request = $this->getAirportWeatherObservationsRequest($id, $temperature_units, $return_nearby_weather, $timestamp, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirportWeatherObservations'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $temperature_units Units to use for temperature fields. (optional, default to Celsius)
     * @param  bool $return_nearby_weather If the requested airport does not have a weather conditions report then the weather for the nearest airport within 30 miles will be returned instead. (optional, default to false)
     * @param  \DateTime $timestamp Timestamp from which to begin returning weather data in a 1 day range. Because weather data is returned in reverse chronological order, all returned weather reports will be from before this timestamp. If unspecified, weather is returned starting from now up to or less than the user history limit, normally 14 days. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportWeatherObservationsRequest($id, $temperature_units = 'Celsius', $return_nearby_weather = 'false', $timestamp = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirportWeatherObservations'
            );
        }

        $resourcePath = '/airports/{id}/weather/observations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($temperature_units !== null) {
            $queryParams['temperature_units'] = ObjectSerializer::toQueryValue($temperature_units, null);
        }
        // query params
        if ($return_nearby_weather !== null) {
            $queryParams['return_nearby_weather'] = ObjectSerializer::toQueryValue($return_nearby_weather, null);
        }
        // query params
        if ($timestamp !== null) {
            $queryParams['timestamp'] = ObjectSerializer::toQueryValue($timestamp, 'date-time');
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAirportsCanonical
     *
     * Get the canonical code of an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $id_type Type of airport code provided in the id parameter (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20016
     */
    public function getAirportsCanonical($id, $id_type = null)
    {
        list($response) = $this->getAirportsCanonicalWithHttpInfo($id, $id_type);
        return $response;
    }

    /**
     * Operation getAirportsCanonicalWithHttpInfo
     *
     * Get the canonical code of an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $id_type Type of airport code provided in the id parameter (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20016, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportsCanonicalWithHttpInfo($id, $id_type = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20016';
        $request = $this->getAirportsCanonicalRequest($id, $id_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20016',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportsCanonicalAsync
     *
     * Get the canonical code of an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $id_type Type of airport code provided in the id parameter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportsCanonicalAsync($id, $id_type = null)
    {
        return $this->getAirportsCanonicalAsyncWithHttpInfo($id, $id_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportsCanonicalAsyncWithHttpInfo
     *
     * Get the canonical code of an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $id_type Type of airport code provided in the id parameter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportsCanonicalAsyncWithHttpInfo($id, $id_type = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20016';
        $request = $this->getAirportsCanonicalRequest($id, $id_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirportsCanonical'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $id_type Type of airport code provided in the id parameter (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportsCanonicalRequest($id, $id_type = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirportsCanonical'
            );
        }

        $resourcePath = '/airports/{id}/canonical';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id_type !== null) {
            $queryParams['id_type'] = ObjectSerializer::toQueryValue($id_type, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAirportsNearAirport
     *
     * Get airports near an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  int $radius The search radius to use for finding nearby airports (statue miles) (required)
     * @param  bool $only_iap Return only nearby airports with Instrument Approaches (also limits results to North American airports) (optional, default to false)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20017
     */
    public function getAirportsNearAirport($id, $radius, $only_iap = 'false', $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getAirportsNearAirportWithHttpInfo($id, $radius, $only_iap, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getAirportsNearAirportWithHttpInfo
     *
     * Get airports near an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  int $radius The search radius to use for finding nearby airports (statue miles) (required)
     * @param  bool $only_iap Return only nearby airports with Instrument Approaches (also limits results to North American airports) (optional, default to false)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20017, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAirportsNearAirportWithHttpInfo($id, $radius, $only_iap = 'false', $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20017';
        $request = $this->getAirportsNearAirportRequest($id, $radius, $only_iap, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20017',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAirportsNearAirportAsync
     *
     * Get airports near an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  int $radius The search radius to use for finding nearby airports (statue miles) (required)
     * @param  bool $only_iap Return only nearby airports with Instrument Approaches (also limits results to North American airports) (optional, default to false)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportsNearAirportAsync($id, $radius, $only_iap = 'false', $max_pages = '1', $cursor = null)
    {
        return $this->getAirportsNearAirportAsyncWithHttpInfo($id, $radius, $only_iap, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAirportsNearAirportAsyncWithHttpInfo
     *
     * Get airports near an airport
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  int $radius The search radius to use for finding nearby airports (statue miles) (required)
     * @param  bool $only_iap Return only nearby airports with Instrument Approaches (also limits results to North American airports) (optional, default to false)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAirportsNearAirportAsyncWithHttpInfo($id, $radius, $only_iap = 'false', $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20017';
        $request = $this->getAirportsNearAirportRequest($id, $radius, $only_iap, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAirportsNearAirport'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  int $radius The search radius to use for finding nearby airports (statue miles) (required)
     * @param  bool $only_iap Return only nearby airports with Instrument Approaches (also limits results to North American airports) (optional, default to false)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAirportsNearAirportRequest($id, $radius, $only_iap = 'false', $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getAirportsNearAirport'
            );
        }
        // verify the required parameter 'radius' is set
        if ($radius === null || (is_array($radius) && count($radius) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $radius when calling getAirportsNearAirport'
            );
        }

        $resourcePath = '/airports/{id}/nearby';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($radius !== null) {
            $queryParams['radius'] = ObjectSerializer::toQueryValue($radius, null);
        }
        // query params
        if ($only_iap !== null) {
            $queryParams['only_iap'] = ObjectSerializer::toQueryValue($only_iap, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAllAirports
     *
     * Get all airports
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20012
     */
    public function getAllAirports($max_pages = '1', $cursor = null)
    {
        list($response) = $this->getAllAirportsWithHttpInfo($max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getAllAirportsWithHttpInfo
     *
     * Get all airports
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20012, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAllAirportsWithHttpInfo($max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20012';
        $request = $this->getAllAirportsRequest($max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20012',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAllAirportsAsync
     *
     * Get all airports
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllAirportsAsync($max_pages = '1', $cursor = null)
    {
        return $this->getAllAirportsAsyncWithHttpInfo($max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAllAirportsAsyncWithHttpInfo
     *
     * Get all airports
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAllAirportsAsyncWithHttpInfo($max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20012';
        $request = $this->getAllAirportsRequest($max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAllAirports'
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAllAirportsRequest($max_pages = '1', $cursor = null)
    {

        $resourcePath = '/airports';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDelaysForAllAirports
     *
     * Get delay information for all airports with delays
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20014
     */
    public function getDelaysForAllAirports($max_pages = '1', $cursor = null)
    {
        list($response) = $this->getDelaysForAllAirportsWithHttpInfo($max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getDelaysForAllAirportsWithHttpInfo
     *
     * Get delay information for all airports with delays
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20014, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDelaysForAllAirportsWithHttpInfo($max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20014';
        $request = $this->getDelaysForAllAirportsRequest($max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20014',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDelaysForAllAirportsAsync
     *
     * Get delay information for all airports with delays
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDelaysForAllAirportsAsync($max_pages = '1', $cursor = null)
    {
        return $this->getDelaysForAllAirportsAsyncWithHttpInfo($max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDelaysForAllAirportsAsyncWithHttpInfo
     *
     * Get delay information for all airports with delays
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDelaysForAllAirportsAsyncWithHttpInfo($max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20014';
        $request = $this->getDelaysForAllAirportsRequest($max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDelaysForAllAirports'
     *
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDelaysForAllAirportsRequest($max_pages = '1', $cursor = null)
    {

        $resourcePath = '/airports/delays';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFlightsBetweenAirports
     *
     * Get flights with a specific origin and destination
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $dest_id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $type Type of flights to return. (optional)
     * @param  string $connection Whether flights should be filtered based on their connection status. Leaving this blank will result in a mix of flights being returned, with a preference for nonstop flights. One-stop flights are identified with a custom heuristic. (optional)
     * @param  \FlightAware\PHPClient\Model\Start7 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End7 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20023
     */
    public function getFlightsBetweenAirports($id, $dest_id, $type = null, $connection = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getFlightsBetweenAirportsWithHttpInfo($id, $dest_id, $type, $connection, $start, $end, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getFlightsBetweenAirportsWithHttpInfo
     *
     * Get flights with a specific origin and destination
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $dest_id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $type Type of flights to return. (optional)
     * @param  string $connection Whether flights should be filtered based on their connection status. Leaving this blank will result in a mix of flights being returned, with a preference for nonstop flights. One-stop flights are identified with a custom heuristic. (optional)
     * @param  \FlightAware\PHPClient\Model\Start7 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End7 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20023, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFlightsBetweenAirportsWithHttpInfo($id, $dest_id, $type = null, $connection = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20023';
        $request = $this->getFlightsBetweenAirportsRequest($id, $dest_id, $type, $connection, $start, $end, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20023',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFlightsBetweenAirportsAsync
     *
     * Get flights with a specific origin and destination
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $dest_id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $type Type of flights to return. (optional)
     * @param  string $connection Whether flights should be filtered based on their connection status. Leaving this blank will result in a mix of flights being returned, with a preference for nonstop flights. One-stop flights are identified with a custom heuristic. (optional)
     * @param  \FlightAware\PHPClient\Model\Start7 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End7 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlightsBetweenAirportsAsync($id, $dest_id, $type = null, $connection = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        return $this->getFlightsBetweenAirportsAsyncWithHttpInfo($id, $dest_id, $type, $connection, $start, $end, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFlightsBetweenAirportsAsyncWithHttpInfo
     *
     * Get flights with a specific origin and destination
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $dest_id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $type Type of flights to return. (optional)
     * @param  string $connection Whether flights should be filtered based on their connection status. Leaving this blank will result in a mix of flights being returned, with a preference for nonstop flights. One-stop flights are identified with a custom heuristic. (optional)
     * @param  \FlightAware\PHPClient\Model\Start7 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End7 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFlightsBetweenAirportsAsyncWithHttpInfo($id, $dest_id, $type = null, $connection = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20023';
        $request = $this->getFlightsBetweenAirportsRequest($id, $dest_id, $type, $connection, $start, $end, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFlightsBetweenAirports'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $dest_id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $type Type of flights to return. (optional)
     * @param  string $connection Whether flights should be filtered based on their connection status. Leaving this blank will result in a mix of flights being returned, with a preference for nonstop flights. One-stop flights are identified with a custom heuristic. (optional)
     * @param  \FlightAware\PHPClient\Model\Start7 $start The starting date range for flight results. The format is ISO8601 date or datetime, and the bound is inclusive. Specified start date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  \FlightAware\PHPClient\Model\End7 $end The ending date range for flight results. The format is ISO8601 date or datetime, and the bound is exclusive. Specified end date must be no further than 10 days in the past and 2 days in the future. If using date instead of datetime, the time will default to 00:00:00Z. (optional)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFlightsBetweenAirportsRequest($id, $dest_id, $type = null, $connection = null, $start = null, $end = null, $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFlightsBetweenAirports'
            );
        }
        // verify the required parameter 'dest_id' is set
        if ($dest_id === null || (is_array($dest_id) && count($dest_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dest_id when calling getFlightsBetweenAirports'
            );
        }

        $resourcePath = '/airports/{id}/flights/to/{dest_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($connection !== null) {
            $queryParams['connection'] = ObjectSerializer::toQueryValue($connection, null);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start, null);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($dest_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dest_id' . '}',
                ObjectSerializer::toPathValue($dest_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNearbyAirports
     *
     * Get airports near a location
     *
     * @param  float $latitude The latitude of the point used to search for nearby airports (required)
     * @param  float $longitude The longitude of the point used to search for nearby airports (required)
     * @param  int $radius The search radius to use for finding nearby airports (statue miles) (required)
     * @param  bool $only_iap Return only nearby airports with Instrument Approaches (also limits results to North American airports) (optional, default to false)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20013
     */
    public function getNearbyAirports($latitude, $longitude, $radius, $only_iap = 'false', $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getNearbyAirportsWithHttpInfo($latitude, $longitude, $radius, $only_iap, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getNearbyAirportsWithHttpInfo
     *
     * Get airports near a location
     *
     * @param  float $latitude The latitude of the point used to search for nearby airports (required)
     * @param  float $longitude The longitude of the point used to search for nearby airports (required)
     * @param  int $radius The search radius to use for finding nearby airports (statue miles) (required)
     * @param  bool $only_iap Return only nearby airports with Instrument Approaches (also limits results to North American airports) (optional, default to false)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20013, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNearbyAirportsWithHttpInfo($latitude, $longitude, $radius, $only_iap = 'false', $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20013';
        $request = $this->getNearbyAirportsRequest($latitude, $longitude, $radius, $only_iap, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20013',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNearbyAirportsAsync
     *
     * Get airports near a location
     *
     * @param  float $latitude The latitude of the point used to search for nearby airports (required)
     * @param  float $longitude The longitude of the point used to search for nearby airports (required)
     * @param  int $radius The search radius to use for finding nearby airports (statue miles) (required)
     * @param  bool $only_iap Return only nearby airports with Instrument Approaches (also limits results to North American airports) (optional, default to false)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNearbyAirportsAsync($latitude, $longitude, $radius, $only_iap = 'false', $max_pages = '1', $cursor = null)
    {
        return $this->getNearbyAirportsAsyncWithHttpInfo($latitude, $longitude, $radius, $only_iap, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNearbyAirportsAsyncWithHttpInfo
     *
     * Get airports near a location
     *
     * @param  float $latitude The latitude of the point used to search for nearby airports (required)
     * @param  float $longitude The longitude of the point used to search for nearby airports (required)
     * @param  int $radius The search radius to use for finding nearby airports (statue miles) (required)
     * @param  bool $only_iap Return only nearby airports with Instrument Approaches (also limits results to North American airports) (optional, default to false)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNearbyAirportsAsyncWithHttpInfo($latitude, $longitude, $radius, $only_iap = 'false', $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20013';
        $request = $this->getNearbyAirportsRequest($latitude, $longitude, $radius, $only_iap, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNearbyAirports'
     *
     * @param  float $latitude The latitude of the point used to search for nearby airports (required)
     * @param  float $longitude The longitude of the point used to search for nearby airports (required)
     * @param  int $radius The search radius to use for finding nearby airports (statue miles) (required)
     * @param  bool $only_iap Return only nearby airports with Instrument Approaches (also limits results to North American airports) (optional, default to false)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNearbyAirportsRequest($latitude, $longitude, $radius, $only_iap = 'false', $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'latitude' is set
        if ($latitude === null || (is_array($latitude) && count($latitude) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $latitude when calling getNearbyAirports'
            );
        }
        // verify the required parameter 'longitude' is set
        if ($longitude === null || (is_array($longitude) && count($longitude) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $longitude when calling getNearbyAirports'
            );
        }
        // verify the required parameter 'radius' is set
        if ($radius === null || (is_array($radius) && count($radius) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $radius when calling getNearbyAirports'
            );
        }

        $resourcePath = '/airports/nearby';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($latitude !== null) {
            $queryParams['latitude'] = ObjectSerializer::toQueryValue($latitude, null);
        }
        // query params
        if ($longitude !== null) {
            $queryParams['longitude'] = ObjectSerializer::toQueryValue($longitude, null);
        }
        // query params
        if ($radius !== null) {
            $queryParams['radius'] = ObjectSerializer::toQueryValue($radius, null);
        }
        // query params
        if ($only_iap !== null) {
            $queryParams['only_iap'] = ObjectSerializer::toQueryValue($only_iap, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRoutesBetweenAirports
     *
     * Get routes between 2 airports
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $dest_id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $sort_by Field to sort results by. \&quot;count\&quot; will sort results by the route filing count (descending). \&quot;last_departure_time\&quot; will sort results by the latest scheduled departure time for that route (descending). (optional, default to count)
     * @param  string $max_file_age Maximum filed plan age of flights to consider. Can be a value less than or equal to 14 days (2 weeks) OR 1 month OR 1 year. (optional, default to 2 weeks)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \FlightAware\PHPClient\Model\InlineResponse20025
     */
    public function getRoutesBetweenAirports($id, $dest_id, $sort_by = 'count', $max_file_age = '2 weeks', $max_pages = '1', $cursor = null)
    {
        list($response) = $this->getRoutesBetweenAirportsWithHttpInfo($id, $dest_id, $sort_by, $max_file_age, $max_pages, $cursor);
        return $response;
    }

    /**
     * Operation getRoutesBetweenAirportsWithHttpInfo
     *
     * Get routes between 2 airports
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $dest_id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $sort_by Field to sort results by. \&quot;count\&quot; will sort results by the route filing count (descending). \&quot;last_departure_time\&quot; will sort results by the latest scheduled departure time for that route (descending). (optional, default to count)
     * @param  string $max_file_age Maximum filed plan age of flights to consider. Can be a value less than or equal to 14 days (2 weeks) OR 1 month OR 1 year. (optional, default to 2 weeks)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \FlightAware\PHPClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \FlightAware\PHPClient\Model\InlineResponse20025, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRoutesBetweenAirportsWithHttpInfo($id, $dest_id, $sort_by = 'count', $max_file_age = '2 weeks', $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20025';
        $request = $this->getRoutesBetweenAirportsRequest($id, $dest_id, $sort_by, $max_file_age, $max_pages, $cursor);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\InlineResponse20025',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\FlightAware\PHPClient\Model\Error',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRoutesBetweenAirportsAsync
     *
     * Get routes between 2 airports
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $dest_id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $sort_by Field to sort results by. \&quot;count\&quot; will sort results by the route filing count (descending). \&quot;last_departure_time\&quot; will sort results by the latest scheduled departure time for that route (descending). (optional, default to count)
     * @param  string $max_file_age Maximum filed plan age of flights to consider. Can be a value less than or equal to 14 days (2 weeks) OR 1 month OR 1 year. (optional, default to 2 weeks)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutesBetweenAirportsAsync($id, $dest_id, $sort_by = 'count', $max_file_age = '2 weeks', $max_pages = '1', $cursor = null)
    {
        return $this->getRoutesBetweenAirportsAsyncWithHttpInfo($id, $dest_id, $sort_by, $max_file_age, $max_pages, $cursor)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRoutesBetweenAirportsAsyncWithHttpInfo
     *
     * Get routes between 2 airports
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $dest_id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $sort_by Field to sort results by. \&quot;count\&quot; will sort results by the route filing count (descending). \&quot;last_departure_time\&quot; will sort results by the latest scheduled departure time for that route (descending). (optional, default to count)
     * @param  string $max_file_age Maximum filed plan age of flights to consider. Can be a value less than or equal to 14 days (2 weeks) OR 1 month OR 1 year. (optional, default to 2 weeks)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRoutesBetweenAirportsAsyncWithHttpInfo($id, $dest_id, $sort_by = 'count', $max_file_age = '2 weeks', $max_pages = '1', $cursor = null)
    {
        $returnType = '\FlightAware\PHPClient\Model\InlineResponse20025';
        $request = $this->getRoutesBetweenAirportsRequest($id, $dest_id, $sort_by, $max_file_age, $max_pages, $cursor);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRoutesBetweenAirports'
     *
     * @param  string $id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $dest_id ICAO, IATA or LID ID of destination airport to fetch. [ICAO is highly preferred](/aeroapi/portal/resources#icaoCode) to prevent ambiguity. (required)
     * @param  string $sort_by Field to sort results by. \&quot;count\&quot; will sort results by the route filing count (descending). \&quot;last_departure_time\&quot; will sort results by the latest scheduled departure time for that route (descending). (optional, default to count)
     * @param  string $max_file_age Maximum filed plan age of flights to consider. Can be a value less than or equal to 14 days (2 weeks) OR 1 month OR 1 year. (optional, default to 2 weeks)
     * @param  int $max_pages Maximum number of pages to fetch. This is an upper limit and not a guarantee of how many pages will be returned. (optional, default to 1)
     * @param  string $cursor Opaque value used to get the next batch of data from a paged collection. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRoutesBetweenAirportsRequest($id, $dest_id, $sort_by = 'count', $max_file_age = '2 weeks', $max_pages = '1', $cursor = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRoutesBetweenAirports'
            );
        }
        // verify the required parameter 'dest_id' is set
        if ($dest_id === null || (is_array($dest_id) && count($dest_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $dest_id when calling getRoutesBetweenAirports'
            );
        }

        $resourcePath = '/airports/{id}/routes/{dest_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($sort_by !== null) {
            $queryParams['sort_by'] = ObjectSerializer::toQueryValue($sort_by, null);
        }
        // query params
        if ($max_file_age !== null) {
            $queryParams['max_file_age'] = ObjectSerializer::toQueryValue($max_file_age, null);
        }
        // query params
        if ($max_pages !== null) {
            $queryParams['max_pages'] = ObjectSerializer::toQueryValue($max_pages, null);
        }
        // query params
        if ($cursor !== null) {
            $queryParams['cursor'] = ObjectSerializer::toQueryValue($cursor, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($dest_id !== null) {
            $resourcePath = str_replace(
                '{' . 'dest_id' . '}',
                ObjectSerializer::toPathValue($dest_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json; charset=UTF-8']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json; charset=UTF-8'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-apikey');
        if ($apiKey !== null) {
            $headers['x-apikey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
